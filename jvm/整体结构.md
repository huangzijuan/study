## 基本结构
![ccc7b011c0819cfe1176484d05365d0](/assets/ccc7b011c0819cfe1176484d05365d0.png)
![6d1a1898b856a7c4ae0a14e8713a1b7](/assets/6d1a1898b856a7c4ae0a14e8713a1b7.png)

在虚拟机执行代码的时候，会通过类装载子系统把class文件装到内存，虚拟机中的字节码执行引擎会到内存中找到这些信息，一行一行执行相关字节码，执行过程中会转换成本地系统认识的代码放到操作系统中，代码的转换过程是在本地库接口中完成的。

## 概念
程序计数器：用来记录程序运行位置的指示器
![240](/assets/240.png)
虚拟机栈：由栈帧组成，栈帧由局部变量表，操作数栈，帧数据区组成。
局部变量表：存放的是函数的入参，以及局部变量。
操作数栈：存放调用过程中的计算结果的临时存放区域。
帧数据区：存放的是异常处理表和函数的返回，访问常量池的指针。


## 内存分配
JVM中内存区可根据受访问权限的不同分为线程共享和线程私有两大类
1. 线程共享（包括堆区、方法区、运行时常量池）
2. 线程私有（栈区、本地方法栈、程序计数器）
每个线程都会有自己的线程栈（大约1M的空间），每个方法对应一个栈帧空间，每个线程有独立的程序计数器
![f4428de61c830dc9f47c5aa409d284b](/assets/f4428de61c830dc9f47c5aa409d284b.png)


## GCRoot
如果一个对象在栈区或是方法区中还直接或间接有强引用存在，那么它就是GC可达的，不能回收

![d8c5d3ebc59eea1e43171a882ff6c86](/assets/d8c5d3ebc59eea1e43171a882ff6c86.png)


## 垃圾回收
参考：https://baijiahao.baidu.com/s?id=1636852721632353675&wfr=spider&for=pc
判断对象是否存活常用的两种方法：引用计数法、可达性分析
常见的垃圾回收算法有：
1. 标记-清理
特点：简单方便、容易产生内存碎片
2. 标记-整理
特点：a 适合存活对象多、垃圾少的情况 b 需要整理的过程
3. 复制算法
将内存按照容量大小划分为相等的两块，每次只使用其中一块。当这块用完了，就将活着的对象复制到另一块上，然后把使用过的内存一次都清理掉
特点：简单、不会产生碎片、内存利用率太低，只用了一半
3. Java堆的垃圾回收：分代回收算法
Java堆空间分成三部分：年轻代、老年代、永久代
年轻代：存活对象少、垃圾多
老年代：存活对象多、垃圾少

年轻代采用复制算法：
年轻代划分为三个部分，比例为Eden：S1：S2=8:1:1
工作原理如下：
工作原理如下：
a、首先，Eden对外提供堆内存。当 Eden区快要满了，触发垃圾回收机制，把存活对象放入 Survivor A 区，清空 Eden 区；
b、Eden区被清空后，继续对外提供堆内存；
c、当 Eden 区再次被填满，对 Eden区和 Survivor A 区同时进行垃圾回收，把存活对象放入 Survivor B区，同时清空 Eden 区和Survivor A 区；
d、当某个 Survivor区被填满，把多余对象放到Old 区；
e、当 Old 区也被填满时，进行 下一阶段的垃圾回收。
老年代采用标记整理算法：
